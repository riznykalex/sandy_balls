
<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>–ü—ñ—â–∞–Ω—ñ –∫—É–ª—å–∫–∏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      color: white;
      text-align: center;
      background: linear-gradient(to bottom, #2c3e50, #000000);
      height: 100vh;
      overflow: hidden;
    }

    button {
      margin: 10px;
      padding: 12px 20px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #555;
      color: white;
    }

    button:active {
      background-color: #888;
    }

    #startScreen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
    }

    #gameScreen {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100%;
    }

    #canvasContainer {
      position: relative;
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      max-width: 500px;
    }

    canvas {
      border: 1px solid rgba(255, 255, 255, 0.2);
      touch-action: none;
      background-color: transparent;
    }
  </style>
</head>
<body>

  <!-- üéÆ –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –µ–∫—Ä–∞–Ω -->
  <div id="startScreen">
    <h1>–ü—ñ—â–∞–Ω—ñ –∫—É–ª—å–∫–∏</h1>
    <p>–û–±–µ—Ä—ñ—Ç—å —Ä—ñ–≤–µ–Ω—å —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ:</p>
    <button onclick="startGame(4)">–õ–µ–≥–∫–∏–π (4 –∫–æ–ª—å–æ—Ä–∏)</button>
    <button onclick="startGame(5)">–°–µ—Ä–µ–¥–Ω—ñ–π (5 –∫–æ–ª—å–æ—Ä—ñ–≤)</button>
    <button onclick="startGame(6)">–°–∫–ª–∞–¥–Ω–∏–π (6 –∫–æ–ª—å–æ—Ä—ñ–≤)</button>
  </div>

  <!-- üïπÔ∏è –Ü–≥—Ä–æ–≤–∏–π –µ–∫—Ä–∞–Ω -->
  <div id="gameScreen">
    <div id="canvasContainer">
      <canvas id="gameCanvas"></canvas>
    </div>
  </div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const GAME_WIDTH = 400;
  const GAME_HEIGHT = 600;
  canvas.width = GAME_WIDTH;
  canvas.height = GAME_HEIGHT;

  function resizeCanvas() {
    const scale = Math.min(
      window.innerWidth / GAME_WIDTH,
      (window.innerHeight - 100) / GAME_HEIGHT
    );
    canvas.style.width = GAME_WIDTH * scale + "px";
    canvas.style.height = GAME_HEIGHT * scale + "px";
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  const gridSize = 8;
  const columns = GAME_WIDTH / gridSize;
  const rows = GAME_HEIGHT / gridSize;

  let keys = {};
  document.addEventListener("keydown", e => keys[e.key] = true);
  document.addEventListener("keyup", e => keys[e.key] = false);

  let control = { left: false, right: false, down: false };

  // üì± –ö–µ—Ä—É–≤–∞–Ω–Ω—è –¥–æ—Ç–∏–∫–æ–º (—Ç–∞–ø-–∑–æ–Ω–∏)
  canvas.addEventListener("touchstart", e => {
    const t = e.touches[0];
    const x = t.clientX;
    const y = t.clientY;

    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    control.left = control.right = control.down = false;

    if (y > screenHeight * 0.75) {
      control.down = true; // –Ω–∏–∂–Ω—è –∑–æ–Ω–∞
    } else if (x < screenWidth / 2) {
      control.left = true; // –ª—ñ–≤–∞ –ø–æ–ª–æ–≤–∏–Ω–∞
    } else {
      control.right = true; // –ø—Ä–∞–≤–∞ –ø–æ–ª–æ–≤–∏–Ω–∞
    }
  });

  canvas.addEventListener("touchend", () => {
    control.left = control.right = control.down = false;
  });

  // üïπÔ∏è –ü–µ—Ä–µ—Ö—ñ–¥ –º—ñ–∂ –µ–∫—Ä–∞–Ω–∞–º–∏
  function startGame(level) {
    document.getElementById("startScreen").style.display = "none";
    document.getElementById("gameScreen").style.display = "flex";
    activeColors = colorSets[level];
    ball = new Ball(GAME_WIDTH / 2, 0, getRandomColor(), 50);
    score = 0;
    gameOver = false;
    particles = [];
    grid = Array.from({ length: rows }, () => Array(columns).fill(null));
    pendingParticles = [];
    gameLoop();
  }

  const colorSets = {
    4: ["red", "blue", "yellow", "green"],
    5: ["orange", "purple", "cyan", "lime", "pink"],
    6: ["teal", "magenta", "gold", "navy", "salmon", "turquoise"]
  };

  let score = 0;
  let gameOver = false;
  let particles = [];
  let grid = Array.from({ length: rows }, () => Array(columns).fill(null));
  let pendingParticles = [];
  let activeColors = [];
  let ball;

  function getRandomColor() {
    return activeColors[Math.floor(Math.random() * activeColors.length)];
  }

  class Ball {
    constructor(x, y, color, volume) {
      this.x = x;
      this.y = y;
      this.radius = 16;
      this.color = color;
      this.volume = volume;
      this.speed = 2;
      this.active = true;
    }

    update(grid) {
      if (!this.active || gameOver) return;
      if (keys["ArrowDown"] || control.down) this.y += this.speed * 3;
      else this.y += this.speed;
      if ((keys["ArrowLeft"] || control.left) && this.x - this.radius > 0) this.x -= 4;
      if ((keys["ArrowRight"] || control.right) && this.x + this.radius < GAME_WIDTH) this.x += 4;
      if (this.hasHit(grid)) {
        this.active = false;
        prepareParticles(this);
      }
    }

    draw(ctx) {
      if (!this.active || gameOver) return;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x - this.radius * 0.4, this.y - this.radius * 0.4, this.radius * 0.25, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.4)";
      ctx.fill();
      ctx.closePath();
    }

    hasHit(grid) {
      const bottomY = this.y + this.radius;
      if (bottomY >= GAME_HEIGHT) return true;
      const col = Math.floor(this.x / gridSize);
      const row = Math.floor(bottomY / gridSize);
      return grid[row]?.[col] !== null;
    }
  }

  class Particle {
    constructor(col, row, color) {
      this.col = col;
      this.row = row;
      this.color = color;
    }

    update(grid) {
      if (this.row < rows - 1) {
        if (grid[this.row + 1][this.col] === null) {
          grid[this.row][this.col] = null;
          this.row++;
          grid[this.row][this.col] = this.color;
          return;
        }
        if (this.col > 0 && grid[this.row + 1][this.col - 1] === null) {
          grid[this.row][this.col] = null;
          this.row++;
          this.col--;
          grid[this.row][this.col] = this.color;
          return;
        }
        if (this.col < columns - 1 && grid[this.row + 1][this.col + 1] === null) {
          grid[this.row][this.col] = null;
          this.row++;
          this.col++;
          grid[this.row][this.col] = this.color;
          return;
        }
      }
    }

    draw(ctx) {
      const cx = this.col * gridSize + gridSize / 2;
      const cy = this.row * gridSize + gridSize / 2;
      ctx.beginPath();
      ctx.arc(cx, cy, gridSize / 2, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx - gridSize * 0.2, cy - gridSize * 0.2, gridSize * 0.2, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.4)";
      ctx.fill();
      ctx.closePath();
    }
  }

  function prepareParticles(ball) {
    const centerCol = Math.floor(ball.x / gridSize);
    for (let i = 0; i < ball.volume; i++) {
      let offset = Math.floor(Math.random() * 10) - 5;
      let col = Math.max(0, Math.min(columns - 1, centerCol + offset));
      pendingParticles.push({ col, color: ball.color });
    }
  }

  function releasePendingParticles() {
    if (pendingParticles.length > 0) {
      let batch = pendingParticles.splice(0, 2);
      for (let item of batch) {
        for (let row = rows - 1; row >= 0; row--) {
          if (grid[row][item.col] === null) {
            grid[row][item.col] = item.color;
            particles.push(new Particle(item.col, row, item.color));
            break;
          }
        }
      }
    } else if (!ball.active && !gameOver) {
      if (canSpawnBall()) ball = new Ball(GAME_WIDTH / 2, 0, getRandomColor(), 50);
      else triggerGameOver();
    }
  }

  function canSpawnBall() {
    return grid[0][Math.floor(GAME_WIDTH / 2 / gridSize)] === null;
  }

  function updateParticles() {
    for (let p of particles) p.update(grid);
  }

  function drawParticles() {
    for (let p of particles) p.draw(ctx);
  }

  function checkConnectedGroups() {
    if (pendingParticles.length > 0) return;
    let visited = Array.from({ length: rows }, () => Array(columns).fill(false));
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        let color = grid[row][col];
        if (color === null || visited[row][col]) continue;
        let group = findConnectedGroup(row, col, color, visited);
        if (touchesBothEdges(group)) {
          for (let [r, c] of group) grid[r][c] = null;
          particles = particles.filter(p => !group.some(([r, c]) => p.row === r && p.col === c));
          score += group.length * 10;
        }
      }
    }
    applyGravity();
  }

  function applyGravity() {
    for (let col = 0; col < columns; col++) {
      let writeRow = rows - 1;
      for (let row = rows - 1; row >= 0; row--) {
        if (grid[row][col] !== null) {
          let color = grid[row][col];
          grid[row][col] = null;
          grid[writeRow][col] = color;
          let p = particles.find(pp => pp.col === col && pp.row === row && pp.color === color);
          if (p) p.row = writeRow;
          writeRow--;
        }
      }
    }
  }

  function findConnectedGroup(row, col, color, visited) {
    let stack = [[row, col]], group = [];
    while (stack.length > 0) {
      let [r, c] = stack.pop();
      if (r < 0 || r >= rows || c < 0 || c >= columns) continue;
      if (visited[r][c] || grid[r][c] !== color) continue;
      visited[r][c] = true;
      group.push([r, c]);
      stack.push([r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]);
    }
    return group;
  }

  function touchesBothEdges(group) {
    let left = false, right = false;
    for (let [r, c] of group) {
      if (c === 0) left = true;
      if (c === columns - 1) right = true;
    }
    return left && right;
  }

  function drawScore() {
    ctx.fillStyle = "white";
    ctx.font = "20px Arial";
    ctx.textAlign = "left";
    ctx.fillText("–†–∞—Ö—É–Ω–æ–∫: " + score, 10, 30);
  }

  // --- Game Over ---
  let gameOverTimer = 0;
  let explosionParticles = [];

  function triggerGameOver() {
    gameOver = true;
    gameOverTimer = 0;

    explosionParticles = particles.map(p => ({
      x: p.col * gridSize + gridSize / 2,
      y: p.row * gridSize + gridSize / 2,
      color: p.color,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6
    }));
  }

  function drawGameOver() {
    if (!gameOver) return;

    gameOverTimer++;

    ctx.fillStyle = "white";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText("–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞", GAME_WIDTH / 2, GAME_HEIGHT / 2);

    if (gameOverTimer > 60) {
      for (let p of explosionParticles) {
        p.x += p.vx;
        p.y += p.vy;
        ctx.beginPath();
        ctx.arc(p.x, p.y, gridSize / 2, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
      }
    }

    if (gameOverTimer > 120) {
      document.getElementById("gameScreen").style.display = "none";
      document.getElementById("startScreen").style.display = "flex";
      return;
    }

    requestAnimationFrame(drawGameOver);
  }

  function gameLoop() {
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    ball.update(grid);
    ball.draw(ctx);
    releasePendingParticles();
    updateParticles();
    checkConnectedGroups();
    drawParticles();
    drawScore();

    if (!gameOver) {
      requestAnimationFrame(gameLoop);
    } else {
      drawGameOver();
    }
  }
</script>
</body>
</html>
