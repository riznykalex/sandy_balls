<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>–ü—ñ—â–∞–Ω—ñ –∫—É–ª—å–∫–∏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    body {
      background-color: #111;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
    }
    canvas {
      background-color: #222;
      display: block;
      border: 2px solid #fff;
      touch-action: none; /* —â–æ–± –±—Ä–∞—É–∑–µ—Ä –Ω–µ —Å–∫—Ä–æ–ª–∏–≤ –ø—ñ–¥ —á–∞—Å —Å–≤–∞–π–ø—ñ–≤ */
    }
    #menu {
      margin: 20px 0;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>–ü—ñ—â–∞–Ω—ñ –∫—É–ª—å–∫–∏</h1>
  <div id="menu">
    <p>–û–±–µ—Ä—ñ—Ç—å —Ä—ñ–≤–µ–Ω—å —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ:</p>
    <button onclick="startGame(4)">–õ–µ–≥–∫–∏–π (4 –∫–æ–ª—å–æ—Ä–∏)</button>
    <button onclick="startGame(5)">–°–µ—Ä–µ–¥–Ω—ñ–π (5 –∫–æ–ª—å–æ—Ä—ñ–≤)</button>
    <button onclick="startGame(6)">–°–∫–ª–∞–¥–Ω–∏–π (6 –∫–æ–ª—å–æ—Ä—ñ–≤)</button>
  </div>
  <canvas id="gameCanvas" style="display:none;"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π —Ä–æ–∑–º—ñ—Ä (–ª–æ–≥—ñ–∫–∞ –≥—Ä–∏ —Ç—É—Ç)
    const GAME_WIDTH = 400;
    const GAME_HEIGHT = 600;
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;

    // –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è –∫–∞–Ω–≤–∞—Å–∞
    function resizeCanvas() {
      const scale = Math.min(
        window.innerWidth / GAME_WIDTH,
        (window.innerHeight - 100) / GAME_HEIGHT // —Ç—Ä—ñ—à–∫–∏ –∑–∞–ª–∏—à–∞—î–º–æ –º—ñ—Å—Ü—è –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫—É
      );
      canvas.style.width = GAME_WIDTH * scale + "px";
      canvas.style.height = GAME_HEIGHT * scale + "px";
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const gridSize = 8;
    const columns = GAME_WIDTH / gridSize;
    const rows = GAME_HEIGHT / gridSize;

    let keys = {};
    document.addEventListener("keydown", e => keys[e.key] = true);
    document.addEventListener("keyup", e => keys[e.key] = false);

    // üü¢ –£–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è –º–∏—à–∫–æ—é/—Ç–∞—á–µ–º
    let control = { left: false, right: false, down: false };

    function startPointer(x, y) {
      if (!ball || !ball.active || gameOver) return;
      if (x < ball.x - ball.radius) {
        control.left = true;
      } else if (x > ball.x + ball.radius) {
        control.right = true;
      } else if (y > ball.y) {
        control.down = true;
      }
    }
    function endPointer() {
      control.left = false;
      control.right = false;
      control.down = false;
    }

    function getRelativeCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = GAME_WIDTH / rect.width;
      const scaleY = GAME_HEIGHT / rect.height;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    canvas.addEventListener("mousedown", e => {
      const { x, y } = getRelativeCoords(e.clientX, e.clientY);
      startPointer(x, y);
    });
    canvas.addEventListener("mouseup", endPointer);
    canvas.addEventListener("mouseleave", endPointer);

    canvas.addEventListener("touchstart", e => {
      const t = e.touches[0];
      const { x, y } = getRelativeCoords(t.clientX, t.clientY);
      startPointer(x, y);
    });
    canvas.addEventListener("touchend", endPointer);
    canvas.addEventListener("touchcancel", endPointer);

    let score = 0;
    let gameOver = false;
    let particles = [];
    let grid = Array.from({ length: rows }, () => Array(columns).fill(null));
    let pendingParticles = [];
    let activeColors = [];
    let ball;

    const colorSets = {
      4: ["red", "blue", "yellow", "green"],
      5: ["orange", "purple", "cyan", "lime", "pink"],
      6: ["teal", "magenta", "gold", "navy", "salmon", "turquoise"]
    };

    function startGame(level) {
      activeColors = colorSets[level];
      document.getElementById("menu").style.display = "none";
      canvas.style.display = "block";
      resizeCanvas();
      ball = new Ball(GAME_WIDTH / 2, 0, getRandomColor(), 50);
      gameLoop();
    }

    function getRandomColor() {
      return activeColors[Math.floor(Math.random() * activeColors.length)];
    }

    class Ball {
      constructor(x, y, color, volume) {
        this.x = x;
        this.y = y;
        this.radius = 16;
        this.color = color;
        this.volume = volume;
        this.speed = 2;
        this.active = true;
      }

      update(grid) {
        if (!this.active || gameOver) return;

        // –ø–∞–¥—ñ–Ω–Ω—è
        if (keys["ArrowDown"] || control.down) {
          this.y += this.speed * 3;
        } else {
          this.y += this.speed;
        }

        // –≤–ª—ñ–≤–æ
        if ((keys["ArrowLeft"] || control.left) && this.x - this.radius > 0) {
          this.x -= 4;
        }
        // –≤–ø—Ä–∞–≤–æ
        if ((keys["ArrowRight"] || control.right) && this.x + this.radius < GAME_WIDTH) {
          this.x += 4;
        }

        if (this.hasHit(grid)) {
          this.active = false;
          prepareParticles(this);
        }
      }

      draw(ctx) {
        if (!this.active || gameOver) return;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }

      hasHit(grid) {
        const bottomY = this.y + this.radius;
        if (bottomY >= GAME_HEIGHT) return true;
        const col = Math.floor(this.x / gridSize);
        const row = Math.floor(bottomY / gridSize);
        return grid[row]?.[col] !== null;
      }
    }

    class Particle {
      constructor(col, row, color) {
        this.col = col;
        this.row = row;
        this.color = color;
      }

      update(grid) {
        if (this.row < rows - 1) {
          if (grid[this.row + 1][this.col] === null) {
            grid[this.row][this.col] = null;
            this.row++;
            grid[this.row][this.col] = this.color;
            return;
          }
          if (this.col > 0 && grid[this.row + 1][this.col - 1] === null) {
            grid[this.row][this.col] = null;
            this.row++;
            this.col--;
            grid[this.row][this.col] = this.color;
            return;
          }
          if (this.col < columns - 1 && grid[this.row + 1][this.col + 1] === null) {
            grid[this.row][this.col] = null;
            this.row++;
            this.col++;
            grid[this.row][this.col] = this.color;
            return;
          }
        }
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(
          this.col * gridSize + gridSize / 2,
          this.row * gridSize + gridSize / 2,
          gridSize / 2,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    function prepareParticles(ball) {
      let centerCol = Math.floor(ball.x / gridSize);
      for (let i = 0; i < ball.volume; i++) {
        let offset = Math.floor(Math.random() * 10) - 5;
        let col = Math.max(0, Math.min(columns - 1, centerCol + offset));
        pendingParticles.push({ col, color: ball.color });
      }
    }

    function releasePendingParticles() {
      if (pendingParticles.length > 0) {
        let batch = pendingParticles.splice(0, 2);
        for (let item of batch) {
          for (let row = rows - 1; row >= 0; row--) {
            if (grid[row][item.col] === null) {
              grid[row][item.col] = item.color;
              particles.push(new Particle(item.col, row, item.color));
              break;
            }
          }
        }
      } else if (!ball.active && !gameOver) {
        if (canSpawnBall()) {
          ball = new Ball(GAME_WIDTH / 2, 0, getRandomColor(), 50);
        } else {
          gameOver = true;
        }
      }
    }

    function canSpawnBall() {
      const col = Math.floor(GAME_WIDTH / 2 / gridSize);
      const row = 0;
      return grid[row][col] === null;
    }

    function updateParticles() {
      for (let p of particles) {
        p.update(grid);
      }
    }

    function drawParticles() {
      for (let p of particles) {
        p.draw(ctx);
      }
    }

    function checkConnectedGroups() {
      if (pendingParticles.length > 0) return;

      let visited = Array.from({ length: rows }, () => Array(columns).fill(false));
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < columns; col++) {
          let color = grid[row][col];
          if (color === null || visited[row][col]) continue;
          let group = findConnectedGroup(row, col, color, visited);
          if (touchesBothEdges(group)) {
            for (let [r, c] of group) grid[r][c] = null;
            particles = particles.filter(
              p => !group.some(([r, c]) => p.row === r && p.col === c)
            );
            score += group.length * 10;
          }
        }
      }

      applyGravity();
    }

    function applyGravity() {
      for (let col = 0; col < columns; col++) {
        let writeRow = rows - 1;
        for (let row = rows - 1; row >= 0; row--) {
          if (grid[row][col] !== null) {
            let color = grid[row][col];
            grid[row][col] = null;
            grid[writeRow][col] = color;

            let p = particles.find(
              pp => pp.col === col && pp.row === row && pp.color === color
            );
            if (p) p.row = writeRow;

            writeRow--;
          }
        }
      }
    }

    function findConnectedGroup(row, col, color, visited) {
      let stack = [[row, col]];
      let group = [];
      while (stack.length > 0) {
        let [r, c] = stack.pop();
        if (r < 0 || r >= rows || c < 0 || c >= columns) continue;
        if (visited[r][c] || grid[r][c] !== color) continue;
        visited[r][c] = true;
        group.push([r, c]);
        stack.push([r+1, c], [r-1, c], [r, c+1], [r, c-1]);
      }
      return group;
    }

    function touchesBothEdges(group) {
      let left = false, right = false;
      for (let [r, c] of group) {
        if (c === 0) left = true;
        if (c === columns - 1) right = true;
      }
      return left && right;
    }

    function drawScore() {
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.textAlign = "left";
      ctx.fillText("–†–∞—Ö—É–Ω–æ–∫: " + score, 10, 30);
    }

    function drawGameOver() {
      if (gameOver) {
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText("–ì—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞", GAME_WIDTH / 2, GAME_HEIGHT / 2);
      }
    }

    function gameLoop() {
      ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      ball.update(grid);
      ball.draw(ctx);
      releasePendingParticles();
      updateParticles();
      checkConnectedGroups();
      drawParticles();
      drawScore();
      drawGameOver();
      if (!gameOver) requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
